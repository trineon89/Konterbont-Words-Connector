// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using KonterbontLODConnector;
//
//    var lodArticle = LodArticle.FromJson(jsonString);

namespace KonterbontLODConnector
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class LodArticle
    {
        [JsonProperty("entry")]
        public Entry Entry { get; set; }

        [JsonProperty("entryImage")]
        public Uri EntryImage { get; set; }

        [JsonProperty("previousEntries")]
        public List<NextEntryElement> PreviousEntries { get; set; }

        [JsonProperty("nextEntries")]
        public List<NextEntryElement> NextEntries { get; set; }
    }

    public partial class Entry
    {
        [JsonProperty("lod_id")]
        public string LodId { get; set; }

        [JsonProperty("partOfSpeech")]
        public string PartOfSpeech { get; set; }

        [JsonProperty("partOfSpeechLabel")]
        public string PartOfSpeechLabel { get; set; }

        [JsonProperty("lemma")]
        public string Lemma { get; set; }

        [JsonProperty("trademark")]
        public bool Trademark { get; set; }

        [JsonProperty("ipa")]
        public string Ipa { get; set; }

        [JsonProperty("microStructures")]
        public List<MicroStructure> MicroStructures { get; set; }

        [JsonProperty("audioString")]
        public string AudioString { get; set; }

        [JsonProperty("audioFiles")]
        public AudioFiles AudioFiles { get; set; }

        [JsonProperty("allSynonyms")]
        public List<object> AllSynonyms { get; set; }

        [JsonProperty("videos")]
        public List<Video> Videos { get; set; }

        [JsonProperty("infoboxes")]
        public List<object> Infoboxes { get; set; }
    }

    public partial class AudioFiles
    {
        [JsonProperty("ogg")]
        public Uri Ogg { get; set; }

        [JsonProperty("aac")]
        public Uri Aac { get; set; }
    }

    public partial class MicroStructure
    {
        [JsonProperty("partOfSpeech")]
        public string PartOfSpeech { get; set; }

        [JsonProperty("partOfSpeechLabel")]
        public string PartOfSpeechLabel { get; set; }

        [JsonProperty("inflection")]
        public Inflection Inflection { get; set; }

        [JsonProperty("grammaticalUnits")]
        public List<GrammaticalUnit> GrammaticalUnits { get; set; }
    }

    public partial class GrammaticalUnit
    {
        [JsonProperty("meanings")]
        public List<LODMeaning> Meanings { get; set; }
    }

    public partial class LODMeaning
    {
        [JsonProperty("meaningID")]
        public string MeaningId { get; set; }

        [JsonProperty("meaningVideo")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long MeaningVideo { get; set; }

        [JsonProperty("targetLanguages")]
        public TargetLanguages TargetLanguages { get; set; }

        [JsonProperty("examples")]
        public List<LODExample> LODExamples { get; set; }

        [JsonProperty("inflection", NullValueHandling = NullValueHandling.Ignore)]
        public Inflection Inflection { get; set; }

        [JsonProperty("declensionInfo", NullValueHandling = NullValueHandling.Ignore)]
        public string DeclensionInfo { get; set; }
    }

    public partial class LODExample
    {
        [JsonProperty("parts")]
        public List<ExamplePart> Parts { get; set; }

        [JsonProperty("hasInfobox")]
        public bool HasInfobox { get; set; }
    }

    public partial class ExamplePart
    {
        [JsonProperty("type")]
        public FluffyType Type { get; set; }

        [JsonProperty("parts")]
        public List<PartPart> Parts { get; set; }

        [JsonProperty("glossType", NullValueHandling = NullValueHandling.Ignore)]
        public string GlossType { get; set; }
    }

    public partial class PartPart
    {
        [JsonProperty("type")]
        public PurpleType Type { get; set; }

        [JsonProperty("content")]
        public string Content { get; set; }

        [JsonProperty("joinWithPreviousWord", NullValueHandling = NullValueHandling.Ignore)]
        public bool? JoinWithPreviousWord { get; set; }
    }

    public partial class TargetLanguages
    {
        [JsonProperty("de")]
        public De De { get; set; }

        [JsonProperty("fr")]
        public De Fr { get; set; }

        [JsonProperty("en")]
        public De En { get; set; }

        [JsonProperty("pt")]
        public De Pt { get; set; }
    }

    public partial class De
    {
        [JsonProperty("parts")]
        public List<DePart> Parts { get; set; }
    }

    public partial class DePart
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("content")]
        public string Content { get; set; }
    }

    public partial class Inflection
    {
        [JsonProperty("forms")]
        public List<LODForm> Forms { get; set; }

        [JsonProperty("declensionInfo", NullValueHandling = NullValueHandling.Ignore)]
        public string DeclensionInfo { get; set; }
    }

    public partial class LODForm
    {
        [JsonProperty("content")]
        public string Content { get; set; }

        [JsonProperty("nRuleForm", NullValueHandling = NullValueHandling.Ignore)]
        public string nRuleForm { get; set; }
    }

    public partial class Video
    {
        [JsonProperty("meaningID")]
        public string MeaningId { get; set; }

        [JsonProperty("meaningVideo")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long MeaningVideo { get; set; }
    }

    public partial class NextEntryElement
    {
        [JsonProperty("lodID")]
        public string LodId { get; set; }

        [JsonProperty("lemma")]
        public string Lemma { get; set; }
    }

    public enum PurpleType { Attribute, InflectedHeadword, Word };

    public enum FluffyType { Gloss, Text };

    public partial class LodArticle
    {
        public static LodArticle FromJson(string json) => JsonConvert.DeserializeObject<LodArticle>(json, KonterbontLODConnector.Converter.Settings);
    }

    internal class PurpleTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleType) || t == typeof(PurpleType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "attribute":
                    return PurpleType.Attribute;
                case "inflectedHeadword":
                    return PurpleType.InflectedHeadword;
                case "word":
                    return PurpleType.Word;
            }
            throw new Exception("Cannot unmarshal type PurpleType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurpleType)untypedValue;
            switch (value)
            {
                case PurpleType.Attribute:
                    serializer.Serialize(writer, "attribute");
                    return;
                case PurpleType.InflectedHeadword:
                    serializer.Serialize(writer, "inflectedHeadword");
                    return;
                case PurpleType.Word:
                    serializer.Serialize(writer, "word");
                    return;
            }
            throw new Exception("Cannot marshal type PurpleType");
        }

        public static readonly PurpleTypeConverter Singleton = new PurpleTypeConverter();
    }

    internal class FluffyTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FluffyType) || t == typeof(FluffyType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "gloss":
                    return FluffyType.Gloss;
                case "text":
                    return FluffyType.Text;
            }
            throw new Exception("Cannot unmarshal type FluffyType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FluffyType)untypedValue;
            switch (value)
            {
                case FluffyType.Gloss:
                    serializer.Serialize(writer, "gloss");
                    return;
                case FluffyType.Text:
                    serializer.Serialize(writer, "text");
                    return;
            }
            throw new Exception("Cannot marshal type FluffyType");
        }

        public static readonly FluffyTypeConverter Singleton = new FluffyTypeConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }
}
